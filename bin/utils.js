const fs = require('fs');
const os = require('os');
const path = require('path');
const https = require('https');
const readlineSync = require('readline-sync');
const readline = require('readline');
const { execSync } = require('child_process');

// Handle optional dependencies gracefully
let xlsx, fs_extra, packageJson, generateHTML;

try {
  xlsx = require('xlsx');
} catch (e) {
  console.warn('Warning: xlsx module not found. Excel features will be disabled.');
}

try {
  fs_extra = require('fs-extra');
} catch (e) {
  console.warn('Warning: fs-extra module not found. Some file operations may be limited.');
}

try {
  packageJson = require('../package.json');
} catch (e) {
  packageJson = { version: '1.0.0' };
}

try {
  generateHTML = require('./generate-html');
} catch (e) {
  // Provide a fallback HTML generator
  generateHTML = (name) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${name}</title>
</head>
<body>
    <h1>Welcome to ${name}</h1>
    <p>Generated by EASIER CLI Tool</p>
</body>
</html>`;
}

const { cyan, red, green, reset, yellow } = require('./colors_easier') || {
  cyan: '\x1b[36m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  reset: '\x1b[0m',
  yellow: '\x1b[33m'
};

// Store context information for sequential thinking and memory
const contextMemory = {
  lastOperations: [],
  userPreferences: {},
  downloadHistory: []
};

const easierInfo = {
  name: "Easier",
  description: "A versatile CLI tool designed to simplify development and templating processes for various frameworks like React Native, React.js, Angular, and more. Make development and project setup easier!",
  contact: "Contact us at easier@gmail.com",
};

const banner = `
  ************************************************************
  *                                                          *
  *                 ${green}EASIER CLI Tool${reset}                  *
  *                  Enhanced Version                        *
  *               Artifact Download Ready                    *
  *                                                          *
  ************************************************************
  `;

let commandStartTime = Date.now();

// Sequential thinking: Store operation in memory for context
function storeOperation(operation, details) {
  contextMemory.lastOperations.push({
    timestamp: new Date().toISOString(),
    operation,
    details,
    platform: os.platform(),
    arch: os.arch()
  });
  
  // Keep only last 10 operations to prevent memory bloat
  if (contextMemory.lastOperations.length > 10) {
    contextMemory.lastOperations.shift();
  }
}

// Detect Operating System with enhanced information
function detectOperatingSystem() {
  const platform = os.platform();
  const arch = os.arch();
  const release = os.release();
  
  let osInfo = {
    platform,
    arch,
    release,
    displayName: 'Unknown OS',
    downloadKey: 'unknown'
  };

  switch (platform) {
    case 'win32':
      osInfo.displayName = `Windows ${arch === 'x64' ? '64-bit' : '32-bit'}`;
      osInfo.downloadKey = arch === 'x64' ? 'el-windows-x64' : 'el-windows-x86';
      break;
    case 'darwin':
      osInfo.displayName = `macOS ${arch === 'arm64' ? 'Apple Silicon' : 'Intel'}`;
      osInfo.downloadKey = arch === 'arm64' ? 'el-macos-arm64' : 'el-macos-x64';
      break;
    case 'linux':
      osInfo.displayName = `Linux ${arch}`;
      osInfo.downloadKey = `el-linux-${arch}`;
      break;
    default:
      osInfo.displayName = `${platform} ${arch}`;
      osInfo.downloadKey = `el-${platform}-${arch}`;
  }

  return osInfo;
}

// Enhanced OS Selection Menu using readline-sync
function selectOperatingSystem(availableArtifacts) {
  console.log(`${cyan}üì¶ Available Language Artifacts:${reset}\n`);
  
  const osOptions = [];
  const artifactMap = {};
  
  // Map artifacts to friendly OS names
  availableArtifacts.forEach((artifact, index) => {
    let displayName = 'Unknown OS';
    let description = '';
    
    switch (artifact.name) {
      case 'el-windows-x64':
        displayName = 'Windows 64-bit';
        description = 'For Windows 10/11 64-bit systems';
        break;
      case 'el-windows-x86':
        displayName = 'Windows 32-bit';
        description = 'For Windows 10/11 32-bit systems (legacy)';
        break;
      case 'el-macos-x64':
        displayName = 'macOS Intel';
        description = 'For Intel-based Mac systems';
        break;
      case 'el-macos-arm64':
        displayName = 'macOS Apple Silicon';
        description = 'For M1/M2/M3 Mac systems';
        break;
      case 'el-linux-x64':
        displayName = 'Linux 64-bit';
        description = 'For most Linux distributions (64-bit)';
        break;
      case 'release-packages-linux':
        displayName = 'Linux Release Package';
        description = 'Complete Linux release with dependencies';
        break;
      case 'release-packages-windows':
        displayName = 'Windows Release Package';
        description = 'Complete Windows release with dependencies';
        break;
      case 'release-packages-macos':
        displayName = 'macOS Release Package';
        description = 'Complete macOS release with dependencies';
        break;
      default:
        displayName = artifact.name;
        description = `Size: ${(artifact.size_in_bytes / 1024 / 1024).toFixed(2)} MB`;
    }
    
    osOptions.push(`${displayName} - ${description}`);
    artifactMap[index] = artifact;
  });

  // Add auto-detect option
  const currentOS = detectOperatingSystem();
  osOptions.unshift(`Auto-detect: ${currentOS.displayName} (Recommended)`);
  
  console.log(`${yellow}üí° Detected System: ${currentOS.displayName}${reset}\n`);
  
  const selectedIndex = readlineSync.keyInSelect(
    osOptions, 
    `${cyan}Select your operating system:${reset}`,
    {
      guide: false,
      cancel: 'Exit without downloading'
    }
  );

  if (selectedIndex === -1) {
    console.log(`${yellow}‚ùå Download cancelled by user${reset}`);
    return null;
  }

  if (selectedIndex === 0) {
    // Auto-detect selected
    console.log(`${green}üéØ Auto-detected: ${currentOS.displayName}${reset}`);
    
    // Find matching artifact for current OS
    const matchingArtifact = availableArtifacts.find(artifact => 
      artifact.name === currentOS.downloadKey || 
      artifact.name.includes(currentOS.platform)
    );
    
    if (matchingArtifact) {
      return matchingArtifact;
    } else {
      console.log(`${yellow}‚ö† No specific artifact found for your OS. Showing manual selection...${reset}\n`);
      return selectFromAvailable(availableArtifacts, artifactMap);
    }
  } else {
    // Manual selection (subtract 1 because we added auto-detect at index 0)
    const artifact = artifactMap[selectedIndex - 1];
    console.log(`${green}‚úÖ Selected: ${osOptions[selectedIndex]}${reset}`);
    return artifact;
  }
}

function selectFromAvailable(availableArtifacts, artifactMap) {
  const manualIndex = readlineSync.keyInSelect(
    availableArtifacts.map(a => `${a.name} (${(a.size_in_bytes / 1024 / 1024).toFixed(2)} MB)`),
    `${cyan}Select artifact manually:${reset}`,
    { guide: false, cancel: 'Cancel' }
  );
  
  if (manualIndex === -1) {
    return null;
  }
  
  return availableArtifacts[manualIndex];
}

// Mock function to simulate fetching artifacts from GitHub API
async function fetchAvailableArtifacts(repoOwner, repoName) {
  console.log(`${cyan}üîç Fetching available artifacts...${reset}`);
  
  // Simulated artifacts data - replace with real API call
  // In production, you would call: https://api.github.com/repos/{owner}/{repo}/releases/latest
  const mockArtifacts = [
    {
      id: 1,
      name: 'el-windows-x64',
      size_in_bytes: 15600000,
      browser_download_url: 'https://github.com/Daftyon/Easier-language/archive/refs/heads/main.zip',
      created_at: new Date().toISOString()
    },
    {
      id: 2,
      name: 'el-macos-x64',
      size_in_bytes: 6790000,
      browser_download_url: 'https://github.com/Daftyon/Easier-language/archive/refs/heads/main.zip',
      created_at: new Date().toISOString()
    },
    {
      id: 3,
      name: 'el-linux-x64',
      size_in_bytes: 15600000,
      browser_download_url: 'https://github.com/Daftyon/Easier-language/archive/refs/heads/main.zip',
      created_at: new Date().toISOString()
    }
  ];
  
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  console.log(`${green}‚úÖ Found ${mockArtifacts.length} available artifacts${reset}`);
  return mockArtifacts;
}

// Download artifact with progress indication
async function downloadArtifact(artifact, projectName) {
  return new Promise((resolve, reject) => {
    console.log(`${cyan}üì• Downloading ${artifact.name}...${reset}`);
    console.log(`${yellow}üìä Size: ${(artifact.size_in_bytes / 1024 / 1024).toFixed(2)} MB${reset}`);
    
    const fileName = `${artifact.name}.zip`;
    const file = fs.createWriteStream(fileName);
    
    const downloadUrl = artifact.browser_download_url || 'https://github.com/Daftyon/Easier-language/archive/refs/heads/main.zip';
    
    https.get(downloadUrl, {
      headers: {
        'User-Agent': 'EASIER-CLI-Tool'
      }
    }, (response) => {
      if (response.statusCode === 200) {
        let downloadedBytes = 0;
        const totalBytes = artifact.size_in_bytes;
        
        response.on('data', (chunk) => {
          downloadedBytes += chunk.length;
          const progress = ((downloadedBytes / totalBytes) * 100).toFixed(1);
          process.stdout.write(`\r${cyan}Progress: ${progress}% (${(downloadedBytes / 1024 / 1024).toFixed(2)} MB / ${(totalBytes / 1024 / 1024).toFixed(2)} MB)${reset}`);
        });
        
        response.pipe(file);
        
        file.on('finish', () => {
          file.close();
          console.log(`\n${green}‚úÖ Download completed: ${fileName}${reset}`);
          
          // Extract the artifact
          extractArtifact(fileName, projectName)
            .then(() => {
              // Clean up zip file
              try {
                fs.unlinkSync(fileName);
              } catch (e) {
                console.warn(`Warning: Could not delete ${fileName}`);
              }
              resolve(projectName);
            })
            .catch(reject);
        });
        
        file.on('error', (err) => {
          fs.unlink(fileName, () => {}); // Delete partial file
          reject(err);
        });
        
      } else if (response.statusCode === 302 || response.statusCode === 301) {
        // Handle redirect
        const location = response.headers.location;
        if (location) {
          console.log(`${yellow}üìç Following redirect...${reset}`);
          reject(new Error('Redirect handling not fully implemented. Please try again.'));
        }
      } else {
        reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
      }
    }).on('error', (err) => {
      reject(err);
    });
  });
}

// Extract artifact using built-in tools
async function extractArtifact(zipFileName, projectName) {
  return new Promise((resolve, reject) => {
    console.log(`${cyan}üìÇ Extracting ${zipFileName}...${reset}`);
    
    try {
      // Create project directory
      if (!fs.existsSync(projectName)) {
        fs.mkdirSync(projectName, { recursive: true });
      }
      
      // Use different extraction methods based on OS
      const platform = os.platform();
      let extractCmd;
      
      if (platform === 'win32') {
        // Windows - use PowerShell
        extractCmd = `powershell -command "Expand-Archive -Path '${zipFileName}' -DestinationPath '${projectName}' -Force"`;
      } else {
        // Unix-like systems - use unzip
        extractCmd = `unzip -o "${zipFileName}" -d "${projectName}"`;
      }
      
      execSync(extractCmd, { stdio: 'inherit' });
      
      console.log(`${green}‚úÖ Extraction completed to: ${projectName}${reset}`);
      
      // Store successful operation in memory
      storeOperation('artifact_extracted', {
        artifact: zipFileName,
        destination: projectName,
        platform
      });
      
      resolve(projectName);
      
    } catch (error) {
      console.error(`${red}‚ùå Extraction failed: ${error.message}${reset}`);
      reject(error);
    }
  });
}

// Enhanced download language function with artifact support
async function downloadEasierLanguageFromArtifacts(projectName, repoOwner = 'Daftyon', repoName = 'Easier-language') {
  try {
    console.log(`${banner}`);
    console.log(`${cyan}üöÄ EASIER Language Artifact Downloader${reset}`);
    console.log(`${yellow}üìã Project: ${projectName}${reset}`);
    console.log(`${yellow}üì¶ Repository: ${repoOwner}/${repoName}${reset}\n`);

    // Store operation start in memory
    storeOperation('download_start', {
      projectName,
      repoOwner,
      repoName,
      detectedOS: detectOperatingSystem()
    });

    // Step 1: Fetch available artifacts
    const availableArtifacts = await fetchAvailableArtifacts(repoOwner, repoName);
    
    if (availableArtifacts.length === 0) {
      console.log(`${red}‚ùå No artifacts found for ${repoOwner}/${repoName}${reset}`);
      return;
    }

    // Step 2: Let user select OS/artifact
    const selectedArtifact = selectOperatingSystem(availableArtifacts);
    
    if (!selectedArtifact) {
      console.log(`${yellow}üö´ Download cancelled${reset}`);
      return;
    }

    // Step 3: Download the selected artifact
    await downloadArtifact(selectedArtifact, projectName);
    
    // Step 4: Post-download setup
    console.log(`\n${green}üéâ Easier Language Setup Complete!${reset}`);
    console.log(`${cyan}üìÇ Project Location: ${path.resolve(projectName)}${reset}`);
    
    // Store successful completion in memory
    storeOperation('download_complete', {
      projectName,
      artifactName: selectedArtifact.name,
      artifactSize: selectedArtifact.size_in_bytes,
      success: true
    });
    
    contextMemory.downloadHistory.push({
      timestamp: new Date().toISOString(),
      projectName,
      artifactName: selectedArtifact.name,
      repoOwner,
      repoName
    });

    console.log(`\n${cyan}üöÄ Next Steps:${reset}`);
    console.log(`1. ${yellow}cd ${projectName}${reset}`);
    console.log(`2. Explore the extracted files`);
    console.log(`3. Start coding with Easier Language!`);
    console.log(`\n${green}Happy coding! üé®‚ú®${reset}`);
    
  } catch (error) {
    console.error(`${red}‚ùå Error during download: ${error.message}${reset}`);
    storeOperation('download_error', {
      projectName,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
}

// Basic functions (keeping originals)
function displayVersion() {
  console.log(`${green}EASIER CLI Tool${reset}`);
  console.log(`Version: ${packageJson.version}`);
  console.log(`Platform: ${detectOperatingSystem().displayName}`);
}

function displayHelp() {
  console.log('\nUsage: easier [command] [options]\n');
  console.log('Commands:\n');
  console.log(`  ${cyan}easier${reset}\t\t\t\tDisplay information about easier.`);
  console.log(`  ${cyan}generate, -g <name>${reset}\t\tGenerate an HTML file with the specified name.`);
  console.log(`  ${cyan}create, -c <folderName>${reset}\t\tCreate a new folder with the specified name.`);
  console.log(`  ${cyan}create-file, -cf <subfolderName> <file-name>${reset}\tCreate a new file in a subfolder.`);
  console.log(`  ${cyan}tree, -t <directory-path>${reset}\tDisplay the directory tree of a specified path.`);
  console.log(`  ${cyan}generate-react-native <app-name>${reset}\tGenerate a React Native app from a EASIER template.`);
  console.log(`  ${cyan}download-language, -dl <project-name>${reset}\tDownload and setup Easier programming language from GitHub.`);
  console.log(`  ${cyan}download-artifacts, -da <project-name>${reset}\tDownload Easier language from pre-built artifacts with OS selection.`);
  console.log(`  ${cyan}context-memory, -cm${reset}\t\t\tDisplay context memory and operation history.\n`);
  console.log('Options:\n');
  console.log(`  ${cyan}--version, -v${reset}\tDisplay the version of the CLI tool`);
  console.log(`  ${cyan}--display-history, -dh${reset}\tDisplay the command history`);
  console.log(`  ${cyan}--info, -i${reset}\tDisplay additional information about EASIER`);
  console.log(`  ${cyan}--remove, -r${reset}\tRemove the EASIER cli`);
  console.log(`  ${cyan}--help, -h${reset}\tDisplay this help message`);
}

function displayeasierInfo() {
  console.log(banner);
  console.log(`${green}${easierInfo.name}${reset}`);
  console.log(easierInfo.description);
  console.log(easierInfo.contact);
  console.log(`\n${cyan}System Information:${reset}`);
  const osInfo = detectOperatingSystem();
  console.log(`Platform: ${osInfo.displayName}`);
  console.log(`Architecture: ${osInfo.arch}`);
  console.log(`Release: ${osInfo.release}`);
}

function generateHTMLFile(name) {
  const htmlContent = generateHTML(name);
  const fileName = `${name.toLowerCase()}.html`;

  fs.writeFile(fileName, htmlContent, (err) => {
    if (err) {
      console.error(`${red}Error creating ${fileName}: ${err.message}${reset}`);
      process.exit(1);
    }
    console.log(`${green}HTML file ${fileName} has been generated successfully.${reset}`);
  });
}

function createFileInSubfolder(subfolderPath, fileName) {
  const filePath = `${subfolderPath}/${fileName}`;

  fs.mkdir(subfolderPath, { recursive: true }, (err) => {
    if (err) {
      console.error(`${red}Error creating ${subfolderPath} folder: ${err.message}${reset}`);
    } else {
      fs.writeFile(filePath, '', (err) => {
        if (err) {
          console.error(`${red}Error creating ${fileName} in ${subfolderPath}: ${err.message}${reset}`);
        } else {
          console.log(`${green}File ${fileName} has been created in ${subfolderPath} successfully.${reset}`);
        }
      });
    }
  });
}

function createFolder(folderName) {
  fs.mkdir(folderName, (err) => {
    if (err) {
      console.error(`${red}Error creating folder ${folderName}: ${err.message}${reset}`);
      process.exit(1);
    }
    console.log(`${green}Folder ${folderName} has been created successfully.${reset}`);
  });
}

function displayDirectoryTree(directoryPath = process.cwd(), exportToFile = false) {
  function traverseDirectory(currentPath, indent = '') {
    const items = fs.readdirSync(currentPath);
    const output = [];

    for (const item of items) {
      const itemPath = path.join(currentPath, item);
      const stats = fs.statSync(itemPath);

      if (stats.isDirectory()) {
        output.push(`${indent}${cyan}${item}${reset}/`);
        output.push(...traverseDirectory(itemPath, `${indent}  `));
      } else {
        output.push(`${indent}${item}`);
      }
    }

    return output;
  }

  const treeOutput = [`${cyan}Directory tree for: ${directoryPath}${reset}`, ...traverseDirectory(directoryPath)].join('\n');

  if (exportToFile) {
    const exportFileName = 'directory_tree.txt';
    fs.writeFileSync(exportFileName, treeOutput);
    console.log(`Directory tree has been exported to ${exportFileName}`);
  } else {
    console.log(treeOutput);
  }
}

function generateReactNativeApp(appName) {
  try {
    const templateRepoUrl = 'https://github.com/HAFDIAHMED/react-native-firebase';

    console.log(`
************************************************************
*                                                          *
*             EASIER CLI Tool                              *
*             Generating your React Native app...          *
*             Please wait...                               *
*                                                          *
************************************************************
    `);

    const tempDir = `temp_${Date.now()}`;
    execSync(`git clone ${templateRepoUrl} ${tempDir}`);

    if (fs_extra) {
      fs_extra.ensureDirSync(appName);
      fs_extra.copySync(tempDir, appName);
      fs_extra.removeSync(tempDir);
    } else {
      // Fallback without fs-extra
      fs.mkdirSync(appName, { recursive: true });
      console.log(`${yellow}Warning: Advanced file operations require fs-extra module${reset}`);
    }

    console.log(`React Native app '${appName}' generated from the GitHub template.`);
    
    process.chdir(appName);
    execSync('yarn install', { stdio: 'inherit' });
    console.log('Node.js modules installed successfully.');
  } catch (error) {
    console.error(`Error generating the app: ${error.message}`);
  }
}

function downloadEasierLanguage(projectName) {
  try {
    const downloadUrl = 'https://github.com/Daftyon/Easier-language/archive/refs/heads/main.zip';
    const zipFileName = 'easier-language.zip';

    console.log(`${banner}`);
    console.log(`${cyan}üì• Downloading Easier language files...${reset}`);
    
    const zipFile = fs.createWriteStream(zipFileName);
    
    https.get(downloadUrl, (response) => {
      if (response.statusCode === 200) {
        response.pipe(zipFile);
        
        zipFile.on('finish', () => {
          zipFile.close();
          console.log(`${green}‚úì Download completed successfully.${reset}`);
          
          try {
            console.log(`${cyan}üìÇ Extracting files...${reset}`);
            
            // Use system extraction
            const platform = os.platform();
            let extractCmd;
            
            if (platform === 'win32') {
              extractCmd = `powershell -command "Expand-Archive -Path '${zipFileName}' -DestinationPath './' -Force"`;
            } else {
              extractCmd = `unzip -o "${zipFileName}"`;
            }
            
            execSync(extractCmd, { stdio: 'inherit' });
            
            const extractedFolderName = 'Easier-language-main';
            if (fs.existsSync(extractedFolderName)) {
              fs.renameSync(extractedFolderName, projectName);
            }
            
            fs.unlinkSync(zipFileName);
            console.log(`${green}‚úì Files extracted to '${projectName}' directory.${reset}`);
            
            console.log(`${green}üéâ Easier Language Setup Complete!${reset}`);
            console.log(`${cyan}Next steps: cd ${projectName} && explore the files${reset}`);
            
          } catch (extractError) {
            console.error(`${red}‚ùå Error extracting files: ${extractError.message}${reset}`);
            if (fs.existsSync(zipFileName)) {
              fs.unlinkSync(zipFileName);
            }
          }
        });
        
      } else {
        console.error(`${red}‚ùå Failed to download: HTTP ${response.statusCode}${reset}`);
      }
    }).on('error', (err) => {
      console.error(`${red}‚ùå Download error: ${err.message}${reset}`);
    });

  } catch (error) {
    console.error(`${red}‚ùå Error setting up download: ${error.message}${reset}`);
  }
}

function writeHistoryToExcel(workbook, excelFilePath, commandName, commandTime, duration) {
  if (!xlsx) {
    // Fallback to simple text logging if xlsx is not available
    const historyText = `${commandTime} - ${commandName} - Duration: ${duration}s\n`;
    fs.appendFileSync(excelFilePath.replace('.xlsx', '.txt'), historyText);
    return;
  }

  try {
    const sheetName = 'CommandHistory';

    if (!workbook.Sheets[sheetName]) {
      workbook.Sheets[sheetName] = xlsx.utils.json_to_sheet([], { header: ['CommandName', 'CommandTime', 'Duration'] });
      workbook.SheetNames.push(sheetName);
    }

    const worksheet = workbook.Sheets[sheetName];
    const lastRow = worksheet['!ref'] ? xlsx.utils.decode_range(worksheet['!ref']).e.r + 1 : 1;

    xlsx.utils.sheet_add_json(worksheet, [{ CommandName: commandName, CommandTime: commandTime, Duration: duration }], { header: ['CommandName', 'CommandTime', 'Duration'], skipHeader: true, origin: lastRow });

    xlsx.writeFile(workbook, excelFilePath);
    commandStartTime = Date.now();
  } catch (error) {
    if (error.code === 'EBUSY') {
      setTimeout(() => writeHistoryToExcel(workbook, excelFilePath, commandName, commandTime, duration), 1000);
    } else {
      console.error(`Error writing to Excel file: ${error.message}`);
    }
  }
}

function historyCommands(commandArgs) {
  const historyFilePath = `${os.homedir()}/command_history.eas`;
  const excelFilePath = `${os.homedir()}/command_history.xlsx`;
  const commandHistory = `${new Date().toISOString()} - ${commandArgs.join(' ')}\n`;

  fs.appendFileSync(historyFilePath, commandHistory);
  const duration = commandStartTime ? (Date.now() - commandStartTime) / 1000 : 'N/A';

  let workbook;
  if (xlsx) {
    try {
      const existingWorkbook = xlsx.readFile(excelFilePath);
      workbook = existingWorkbook;
    } catch (error) {
      workbook = { Sheets: {}, SheetNames: [] };
    }
  }

  const commandName = commandArgs[0] || 'easier';
  const commandTime = new Date().toLocaleDateString();
  
  if (xlsx && workbook) {
    writeHistoryToExcel(workbook, excelFilePath, commandName, commandTime, duration);
  }
  
  // Store in context memory as well
  storeOperation('command_executed', {
    command: commandArgs.join(' '),
    duration
  });
}

function displayCommandHistory() {
  const historyFilePath = `${os.homedir()}/command_history.eas`;

  try {
    const historyContent = fs.readFileSync(historyFilePath, 'utf-8');
    console.log(`${cyan}Command History:${reset}\n${historyContent}`);
  } catch (error) {
    console.error(`${red}Error reading command history: ${error.message}${reset}`);
  }
}

function displayContextMemory() {
  console.log(`${cyan}üß† Context Memory:${reset}\n`);
  
  console.log(`${yellow}Recent Operations:${reset}`);
  if (contextMemory.lastOperations.length === 0) {
    console.log('No recent operations recorded.');
  } else {
    contextMemory.lastOperations.forEach((op, index) => {
      console.log(`${index + 1}. ${op.operation} - ${op.timestamp}`);
      console.log(`   Platform: ${op.platform} ${op.arch}`);
      if (op.details) {
        console.log(`   Details: ${JSON.stringify(op.details, null, 2)}`);
      }
      console.log('');
    });
  }
  
  if (contextMemory.downloadHistory.length > 0) {
    console.log(`${yellow}Download History:${reset}`);
    contextMemory.downloadHistory.forEach((download, index) => {
      console.log(`${index + 1}. ${download.projectName} (${download.artifactName}) - ${download.timestamp}`);
    });
  }
}

function removeEasier() {
  try {
    execSync('npm uninstall -g easier-cli', { stdio: 'inherit' });
    console.log(`${green}EASIER has been removed successfully.${reset}`);
  } catch (error) {
    console.error(`${red}Error removing EASIER: ${error.message}${reset}`);
  }
}

function checkEasierFile() {
  const projectPath = process.cwd();
  const filePath = path.join(projectPath, 'easier.eas');

  fs.access(filePath, fs.constants.F_OK, (err) => {
    if (err) {
      console.log(`${red}The file 'easier.eas' does not exist in the project.${reset}`);
    } else {
      console.log(`${green}The file 'easier.eas' exists in the project.${reset}`);
    }
  });
}

function generateSpringBatchProject(projectName, templatePath) {
  console.log(`${green}Spring Batch project generation feature coming soon!${reset}`);
  console.log(`${yellow}Project: ${projectName}, Template: ${templatePath}${reset}`);
  
  storeOperation('spring_batch_request', {
    projectName,
    templatePath
  });
}

module.exports = { 
  displayVersion, 
  displayHelp,
  displayeasierInfo,
  createFolder,
  generateHTMLFile,
  createFileInSubfolder,
  displayDirectoryTree,
  generateReactNativeApp,
  downloadEasierLanguage,
  downloadEasierLanguageFromArtifacts,
  historyCommands,
  displayCommandHistory,
  removeEasier,
  checkEasierFile,
  generateSpringBatchProject,
  detectOperatingSystem,
  displayContextMemory,
  storeOperation,
  contextMemory,
  cyan, red, green, reset, yellow
};